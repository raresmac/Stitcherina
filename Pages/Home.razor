@page "/"
@using SixLabors.ImageSharp
@using SixLabors.ImageSharp.PixelFormats
@using SixLabors.ImageSharp.Processing
@using System.IO
@using System.Text.Json
@using Stitcherina.Models
@inject IJSRuntime JS

<div class="app-container" @onmouseup="() => isMouseDown = false">
    <div class="container py-5">

        <!-- Header -->
        <div class="header-glass mb-5 text-center animate-pop">
            <h1 class="logo-text">Stitcherina <span>✨</span></h1>
            <p class="subtitle">Smart patterns for smart stitchers.</p>
        </div>

        <!-- Configuration & Controls -->
        <div class="glass-card mb-5 p-4 animate-slide-up">
            <div class="row g-4 align-items-center">
                <div class="col-xl-2 col-md-4">
                    <label class="cute-label">Grid Size (W × H)</label>
                    <div class="input-group">
                        <input type="number" class="cute-input" @bind="targetWidth" />
                        <span class="divider">×</span>
                        <input type="number" class="cute-input" @bind="targetHeight" />
                    </div>
                </div>
                <div class="col-xl-2 col-md-4">
                    <label class="cute-label">Color Merge: @colorTolerance</label>
                    <input type="range" class="cute-range" min="0" max="10" @bind="colorTolerance" />
                </div>
                <div class="col-xl-2 col-md-4">
                    <label class="cute-label">Stitch Style</label>
                    <div class="mode-toggle">
                        <button class="btn-mode @(isTapestryMode ? "active" : "")" @onclick="() => isTapestryMode = true">Tapestry</button>
                        <button class="btn-mode @(!isTapestryMode ? "active" : "")" @onclick="() => isTapestryMode = false">Cross</button>
                    </div>
                </div>
                <div class="col-xl-3 col-md-6">
                    <label class="cute-label">1. Source Photo</label>
                    <InputFile OnChange="HandleFileSelected" class="form-control cute-file" accept="image/*" />
                </div>
                <div class="col-xl-3 col-md-6">
                    <label class="cute-label">2. Actions</label>
                    <div class="actions-container">
                        <button class="btn-generate" @onclick="GeneratePattern">Generate ✨</button>
                        <div class="stack-container">
                            <button class="btn-mini" @onclick="ExportProject" disabled="@(rows == null || !rows.Any())">💾 Save JSON</button>
                            <label class="btn-mini m-0">📂 Load JSON <InputFile OnChange="ImportProject" hidden accept=".json" /></label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        @if (isProcessing)
        {
            <div class="loader-wrap">
                <div class="pixel-spinner"></div>
                <p>Weaving your threads...</p>
            </div>
        }
        else if (rows != null && rows.Any() && !string.IsNullOrEmpty(previewBase64))
        {
            <div class="row g-4 mb-5">
                <!-- Preview Card -->
                <div class="col-lg-5">
                    <div class="glass-card h-100 p-3 text-center">
                        <div class="card-header-cute d-flex justify-content-between align-items-center mb-1">
                            <span class="ms-auto me-auto">Pattern Preview</span>
                            <button class="btn-reset btn-xs" @onclick="ExportImage" title="Download Pattern Image">💾 Image</button>
                        </div>
                        <p class="ultra-small text-muted mb-3">Click the image to edit ✨</p>
                        <div class="preview-box clickable shadow-glow" @onclick="OpenEditor">
                            <img src="@previewBase64" class="pixel-img" alt="Stitcherina preview" />
                            <div class="edit-overlay-hint">Open Editor</div>
                        </div>
                    </div>
                </div>

                <!-- Palette Key -->
                <div class="col-lg-7">
                    <div class="glass-card h-100 p-3">
                        <div class="card-header-cute d-flex justify-content-between align-items-center mb-3">
                            <span>Palette Key (@allColors.Count Colors)</span>
                            <button class="btn-reset" @onclick="ClearAll">Clear All</button>
                        </div>
                        <div class="palette-scroll">
                            <div class="palette-grid">
                                @foreach (var color in allColors)
                                {
                                    <div class="palette-pill">
                                        <div class="swatch" style="background-color: rgb(@color.R, @color.G, @color.B);">
                                            <span>@allColors.IndexOf(color)</span>
                                        </div>
                                        <div class="palette-info">
                                            <code>#@color.R.ToString("X2")@color.G.ToString("X2")@color.B.ToString("X2")</code>
                                            <div class="total-count">@color.TotalStitches stitches</div>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Stitching Guide -->
            <div class="pattern-section animate-slide-up">
                <h3 class="section-title mb-4 text-center">Stitching Guide</h3>
                @foreach (var row in rows)
                {
                    <div class="row-glass @(row.IsCompleted ? "row-done" : "")">
                        <div class="row-info">
                            <input type="checkbox" class="cute-check" checked="@row.IsCompleted" @onchange="(args) => ToggleRowManual(row, args)" />
                            <div class="ms-3">
                                <div class="row-num">Row @row.RowNumber</div>
                                @if (isTapestryMode)
                                {
                                    <div class="row-dir">@row.DirectionLabel</div>
                                }
                            </div>
                        </div>
                        <div class="row-main">
                            @foreach (var segment in row.Segments)
                            {
                                <div class="seg-pill @(segment.IsStitched ? "active" : "")" @onclick="() => ToggleSegment(row, segment)">
                                    <span class="seg-id">ID:@segment.ColorIndex</span>
                                    <span class="seg-val" style="color: @segment.HexColor">@segment.Count █</span>
                                    @if (segment.IsStitched)
                                    {
                                        <span class="seg-check">✓</span>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
        }
    </div>
</div>

<!-- EDITOR OVERLAY -->
@if (isEditorOpen)
{
    <div class="editor-backdrop animate-pop" @onmouseup="() => isMouseDown = false" @onclick="HandleBackdropClick">
        <div class="editor-window shadow-glow" @onclick:stopPropagation>
            <div class="editor-sidebar">
                <h4 class="logo-text-small mb-1">Pixel Editor</h4>

                <div class="tool-section mb-4 mt-3">
                    <label class="cute-label">Zoom: @(zoomSteps[zoomIndex] / 100.0)x</label>
                    <input type="range" class="cute-range" min="0" max="6" step="1" @bind="zoomIndex" />
                </div>

                <div class="tool-section mb-4">
                    <label class="cute-label">Tool</label>
                    <div class="btn-group w-100 shadow-sm">
                        <button class="btn btn-sm @(activeTool == "pencil" ? "btn-primary" : "btn-outline-primary")" @onclick='() => activeTool = "pencil"'>✏️</button>
                        <button class="btn btn-sm @(activeTool == "bucket" ? "btn-primary" : "btn-outline-primary")" @onclick='() => activeTool = "bucket"'>🪣</button>
                    </div>
                </div>

                <div class="tool-section flex-grow-1 pe-2" style="overflow-y: auto;">
                    <label class="cute-label">Palette Select</label>
                    <div class="editor-palette-list">
                        @foreach (var color in allColors)
                        {
                            int idx = allColors.IndexOf(color);
                            <div class="palette-pill mb-2 @(selectedPaletteIdx == idx ? "active-border" : "")" @onclick="() => selectedPaletteIdx = idx" style="cursor: pointer;">
                                <div class="swatch swatch-sm" style="background-color: rgb(@color.R, @color.G, @color.B);">
                                    <span>@idx</span>
                                </div>
                                <div class="palette-info">
                                    <code class="small">#@color.R.ToString("X2")@color.G.ToString("X2")@color.B.ToString("X2")</code>
                                </div>
                            </div>
                        }
                    </div>

                    <div class="mt-4">
                        <label class="cute-label">Add New</label>
                        <div class="d-flex gap-2">
                            <input type="color" class="color-picker-input" @bind="customColor" />
                            <button class="btn btn-xs btn-info flex-grow-1" @onclick="ApplyCustomColorToSelection">Add</button>
                        </div>
                    </div>
                </div>

                <div class="editor-footer pt-3 mt-3 border-top border-secondary">
                    <button class="btn btn-success w-100 mb-2 py-2 fw-bold" @onclick="SaveEditorChanges">Save Changes ✨</button>
                    <button class="btn btn-outline-danger w-100 btn-sm" @onclick="CancelEditor">Cancel</button>
                </div>
            </div>

            <div class="editor-canvas-container" @onmousedown="() => isMouseDown = true" @onmousedown:preventDefault>
                <div class="canvas-grid" style="width: @(zoomSteps[zoomIndex])%; grid-template-columns: repeat(@targetWidth, 1fr); aspect-ratio: @targetWidth/@targetHeight;">
                    @for (int y = 0; y < targetHeight; y++)
                    {
                        @for (int x = 0; x < targetWidth; x++)
                        {
                            int localX = x; int localY = y;
                            <div class="canvas-pixel"
                                 style="background-color: rgb(@(GetPixelColor(localX, localY).R), @(GetPixelColor(localX, localY).G), @(GetPixelColor(localX, localY).B))"
                                 @onmousedown="() => StartPaint(localX, localY)"
                                 @onmouseenter="() => ContinuePaint(localX, localY)">
                            </div>
                        }
                    }
                </div>
            </div>

            @if (isSaving)
            {
                <div class="save-progress-overlay animate-pop">
                    <div class="save-card glass-card p-5 text-center">
                        <h3 class="mb-4 text-info fw-bold">Saving...</h3>
                        <div class="progress mb-3" style="height: 12px; background: rgba(0,0,0,0.5); border-radius: 10px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated bg-info" style="width: @saveProgress%"></div>
                        </div>
                        @if (saveProgress >= 100)
                        {
                            <div class="text-success mt-2">Done! ✨</div>
                        }
                    </div>
                </div>
            }
        </div>
    </div>
}

<style>
    /* CSS Restored and Fixed */
    .container {
        max-width: 1400px;
    }

    .header-glass {
        padding: 2.5rem;
        background: rgba(255,255,255,0.03);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 30px;
    }

    .logo-text {
        font-size: 3.5rem;
        font-weight: 900;
        letter-spacing: -2px;
    }

        .logo-text span {
            color: #f472b6;
            text-shadow: 0 0 20px rgba(244,114,182,0.6);
        }

    .logo-text-small {
        font-size: 1.5rem;
        font-weight: 900;
        color: #38bdf8;
    }

    .glass-card {
        background: rgba(255,255,255,0.05);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 24px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }

    .cute-label {
        color: #38bdf8;
        font-size: 0.75rem;
        font-weight: 800;
        text-transform: uppercase;
        margin-bottom: 8px;
        display: block;
    }

    .cute-input {
        background: rgba(0,0,0,0.3);
        border: 1px solid rgba(255,255,255,0.1);
        color: #fff;
        border-radius: 10px;
        width: 70px;
        text-align: center;
        padding: 6px;
    }

    .divider {
        padding: 0 8px;
        align-self: center;
        opacity: 0.5;
    }

    .mode-toggle {
        display: flex;
        background: rgba(0,0,0,0.3);
        border-radius: 12px;
        padding: 4px;
        border: 1px solid rgba(255,255,255,0.1);
    }

    .btn-mode {
        flex: 1;
        border: none;
        background: transparent;
        color: #fff;
        font-size: 0.8rem;
        padding: 6px;
        border-radius: 8px;
        transition: 0.3s;
    }

        .btn-mode.active {
            background: #38bdf8;
            color: #000;
            font-weight: bold;
        }

    .actions-container {
        display: flex;
        gap: 10px;
        height: 52px;
    }

    .btn-generate {
        flex: 2;
        height: 100%;
        background: linear-gradient(135deg, #38bdf8, #818cf8);
        border: none;
        border-radius: 12px;
        color: #000;
        font-weight: 900;
        transition: 0.3s;
    }

        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(56,189,248,0.5);
        }

    .stack-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
        height: 100%;
    }

    .btn-mini {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        color: #fff;
        font-size: 0.75rem;
        font-weight: bold;
        cursor: pointer;
    }

    .preview-box {
        height: 400px;
        width: 100%;
        background: #000;
        border-radius: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
        cursor: cell;
        border: 1px solid rgba(255,255,255,0.1);
    }

    .edit-overlay-hint {
        position: absolute;
        background: rgba(56, 189, 248, 0.9);
        color: black;
        font-weight: bold;
        padding: 10px 20px;
        border-radius: 50px;
        opacity: 0;
        pointer-events: none;
        transition: 0.3s;
    }

    .preview-box:hover .edit-overlay-hint {
        opacity: 1;
    }

    .pixel-img {
        image-rendering: pixelated;
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
    }

    .palette-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        gap: 10px;
    }

    .palette-pill {
        background: rgba(0,0,0,0.2);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 15px;
        padding: 8px;
        display: flex;
        align-items: center;
        transition: 0.2s;
    }

        .palette-pill.active-border {
            border-color: #38bdf8;
            background: rgba(56, 189, 248, 0.1);
        }

    .swatch {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 2px solid #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        font-weight: bold;
        text-shadow: 1px 1px 2px #000;
    }

    .swatch-sm {
        width: 28px;
        height: 28px;
        font-size: 0.6rem;
    }

    .palette-info {
        margin-left: 10px;
        line-height: 1.2;
    }

    .total-count {
        font-size: 0.65rem;
        color: #38bdf8;
        font-weight: bold;
        text-transform: uppercase;
    }

    .row-glass {
        display: flex;
        background: rgba(255,255,255,0.03);
        border: 1px solid rgba(255,255,255,0.05);
        border-radius: 20px;
        padding: 15px;
        margin-bottom: 12px;
        transition: 0.3s;
    }

    .row-info {
        min-width: 180px;
        display: flex;
        align-items: center;
        border-right: 1px solid rgba(255,255,255,0.1);
    }

    .row-main {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding-left: 20px;
    }

    .row-done {
        opacity: 0.15;
        filter: grayscale(1);
        transform: scale(0.98);
    }

    .seg-pill {
        background: rgba(255,255,255,0.05);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 12px;
        padding: 6px 14px;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: 0.2s;
        position: relative;
    }

    .seg-val {
        font-family: 'Courier New', Courier, monospace;
        font-weight: 900;
        font-size: 1.35rem;
        text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, 0 0 8px rgba(255,255,255,0.5);
    }

    .seg-check {
        position: absolute;
        top: -6px;
        right: -6px;
        background: #28a745;
        color: #fff;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }

    .editor-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(15, 23, 42, 0.96);
        backdrop-filter: blur(8px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
    }

    .editor-window {
        width: 100%;
        max-width: 1250px;
        height: 92vh;
        background: #0f172a;
        border-radius: 30px;
        display: flex;
        border: 1px solid rgba(255,255,255,0.1);
        overflow: hidden;
    }

    .editor-sidebar {
        width: 260px;
        background: rgba(0,0,0,0.4);
        padding: 25px;
        border-right: 1px solid rgba(255,255,255,0.05);
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    .editor-canvas-container {
        flex: 1;
        background: #000;
        display: block;
        overflow: auto;
        cursor: crosshair;
        padding: 150px 100px;
        text-align: center;
    }

    .canvas-grid {
        display: inline-grid;
        background: #000;
        user-select: none;
        border: 0.5px solid #333;
        vertical-align: middle;
    }

    .canvas-pixel {
        width: 100%;
        height: 100%;
        border: 0.1px solid rgba(255,255,255,0.03);
    }

        .canvas-pixel:hover {
            border: 0.5px solid #fff;
            z-index: 5;
        }

    .color-picker-input {
        width: 45px;
        height: 35px;
        border: 1px solid rgba(255,255,255,0.2);
        background: none;
        cursor: pointer;
        border-radius: 5px;
    }

    .btn-xs {
        padding: 4px 10px;
        font-size: 0.75rem;
        border-radius: 8px;
    }

    .btn-reset {
        background: rgba(255,255,255,0.1);
        color: #fff;
        border: 1px solid rgba(255,255,255,0.1);
        transition: 0.2s;
    }

        .btn-reset:hover {
            background: rgba(255,255,255,0.2);
        }

    .pixel-spinner {
        width: 45px;
        height: 45px;
        background: #38bdf8;
        margin: 0 auto 20px;
        animation: spin 0.8s infinite steps(4);
    }

    @@keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }
</style>

@code {
    int targetWidth = 40, targetHeight = 40, colorTolerance = 2;
    bool isProcessing = false, isOriginalSize = false, isTapestryMode = true;
    byte[]? originalImageBytes;
    string? previewBase64 = "";
    List<StitchRow> rows = new();

    // Editor Logic
    bool isEditorOpen = false, isMouseDown = false, isSaving = false, isDirty = false;
    int saveProgress = 0, zoomIndex = 3, selectedPaletteIdx = 0;
    int[] zoomSteps = { 10, 25, 50, 100, 200, 400, 800 };
    int[,] editableGrid = new int[0, 0];
    string activeTool = "pencil", customColor = "#38bdf8";

    public class PaletteColor { public byte R { get; set; } public byte G { get; set; } public byte B { get; set; } public int TotalStitches { get; set; } }
    List<PaletteColor> allColors = new();

    // --- Core Methods ---

    async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            using var stream = e.File.OpenReadStream(maxAllowedSize: 1024 * 1024 * 20);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            originalImageBytes = ms.ToArray();
            await GeneratePattern();
        }
        catch { }
    }

    async Task GeneratePattern()
    {
        if (originalImageBytes == null) return;
        isProcessing = true; StateHasChanged();
        await Task.Delay(200);
        try
        {
            rows.Clear(); allColors.Clear();
            using var image = Image.Load<Rgba32>(originalImageBytes);
            if (image.Width != targetWidth || image.Height != targetHeight)
                image.Mutate(x => x.Resize(new ResizeOptions { Size = new Size(targetWidth, targetHeight), Mode = ResizeMode.Stretch, Sampler = KnownResamplers.NearestNeighbor }));

            editableGrid = new int[targetWidth, targetHeight];
            for (int y = 0; y < targetHeight; y++)
                for (int x = 0; x < targetWidth; x++)
                {
                    var p = image[x, y];
                    int match = FindBestColorMatch(p.R, p.G, p.B);
                    if (match == -1) { allColors.Add(new PaletteColor { R = p.R, G = p.G, B = p.B }); match = allColors.Count - 1; }
                    editableGrid[x, y] = match;
                }
            await RebuildInstructions(false);
        }
        catch { }
        isProcessing = false;
    }

    async Task RebuildInstructions(bool withProgress)
    {
        rows.Clear();
        foreach (var c in allColors) c.TotalStitches = 0;
        int step = Math.Max(1, targetHeight / 10);
        for (int y = 0; y < targetHeight; y++)
        {
            bool shouldReverse = isTapestryMode && (y % 2 != 0);
            var row = new StitchRow { RowNumber = y + 1, DirectionLabel = shouldReverse ? "Right to Left ←" : (isTapestryMode ? "Left to Right →" : "") };
            List<int> pixelIds = new();
            for (int x = 0; x < targetWidth; x++) { int id = editableGrid[x, y]; allColors[id].TotalStitches++; pixelIds.Add(id); }
            int cur = 0;
            while (cur < pixelIds.Count)
            {
                int id = pixelIds[cur]; int cnt = 1;
                while (cur + 1 < pixelIds.Count && pixelIds[cur + 1] == id) { cnt++; cur++; }
                var col = allColors[id];
                row.Segments.Add(new ColorSegment { ColorIndex = id, Count = cnt, HexColor = $"rgb({col.R},{col.G},{col.B})", Rgb = (col.R, col.G, col.B) });
                cur++;
            }
            if (shouldReverse) row.Segments.Reverse();
            rows.Add(row);
            if (withProgress && y % step == 0) { saveProgress = (int)((y / (float)targetHeight) * 100); StateHasChanged(); await Task.Delay(1); }
        }
        ReconstructPreview();
    }

    void ReconstructPreview()
    {
        if (targetWidth <= 0 || targetHeight <= 0 || !allColors.Any()) return;
        using var image = new Image<Rgba32>(targetWidth, targetHeight);
        for (int y = 0; y < targetHeight; y++)
            for (int x = 0; x < targetWidth; x++)
            {
                var c = allColors[editableGrid[x, y]];
                image[x, y] = new Rgba32(c.R, c.G, c.B);
            }
        int zoom = 15;
        using var zoomed = image.Clone(x => x.Resize(targetWidth * zoom, targetHeight * zoom, KnownResamplers.NearestNeighbor));
        using var ms = new MemoryStream();
        zoomed.SaveAsPng(ms);
        previewBase64 = $"data:image/png;base64,{Convert.ToBase64String(ms.ToArray())}";
    }

    // --- Interaction ---

    void StartPaint(int x, int y) { isMouseDown = true; PaintPixel(x, y); }
    void ContinuePaint(int x, int y) { if (isMouseDown && activeTool == "pencil") PaintPixel(x, y); }
    void PaintPixel(int x, int y)
    {
        if (selectedPaletteIdx < 0 || selectedPaletteIdx >= allColors.Count) return;
        int old = editableGrid[x, y];
        if (old == selectedPaletteIdx) return;
        isDirty = true;
        if (activeTool == "pencil") editableGrid[x, y] = selectedPaletteIdx;
        else if (activeTool == "bucket")
        {
            for (int ly = 0; ly < targetHeight; ly++)
                for (int lx = 0; lx < targetWidth; lx++)
                    if (editableGrid[lx, ly] == old) editableGrid[lx, ly] = selectedPaletteIdx;
        }
    }

    async Task SaveEditorChanges()
    {
        isSaving = true; saveProgress = 0; StateHasChanged();
        var usedIndices = new HashSet<int>();
        for (int y = 0; y < targetHeight; y++)
            for (int x = 0; x < targetWidth; x++) usedIndices.Add(editableGrid[x, y]);
        var newPalette = new List<PaletteColor>();
        var indexMap = new Dictionary<int, int>();
        for (int i = 0; i < allColors.Count; i++)
        {
            if (usedIndices.Contains(i)) { indexMap[i] = newPalette.Count; newPalette.Add(allColors[i]); }
        }
        allColors = newPalette;
        for (int y = 0; y < targetHeight; y++)
            for (int x = 0; x < targetWidth; x++) editableGrid[x, y] = indexMap[editableGrid[x, y]];
        await RebuildInstructions(true);
        saveProgress = 100; StateHasChanged(); await Task.Delay(600);
        isSaving = false; isDirty = false; await ToggleScroll(true); isEditorOpen = false;
    }

    async Task HandleBackdropClick()
    {
        if (isSaving) return;
        if (isDirty)
        {
            bool confirm = await JS.InvokeAsync<bool>("confirm", "Unsaved changes! Save before closing?");
            if (confirm) await SaveEditorChanges();
            else await CancelEditor();
        }
        else await CancelEditor();
    }

    async Task ExportImage()
    {
        if (string.IsNullOrEmpty(previewBase64)) return;
        var now = DateTime.Now;
        string name = $"Stitcherina_Pattern_{now:yyyyMMdd_HHmm}.png";
        // Passing 'true' to indicate this is a Data URI
        await JS.InvokeVoidAsync("downloadFile", name, previewBase64, true);
    }

    async Task ExportProject()
    {
        var now = DateTime.Now;
        string name = $"Stitcherina_{now:yyyy-MM-dd_HH-mm-ss}.json";
        var state = new { Width = targetWidth, Height = targetHeight, Tolerance = colorTolerance, Mode = isTapestryMode, Palette = allColors, Rows = rows };
        await JS.InvokeVoidAsync("downloadFile", name, Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(JsonSerializer.Serialize(state))));
    }

    async Task ImportProject(InputFileChangeEventArgs e)
    {
        isProcessing = true; StateHasChanged();
        try
        {
            using var reader = new StreamReader(e.File.OpenReadStream());
            var doc = JsonDocument.Parse(await reader.ReadToEndAsync()).RootElement;
            targetWidth = doc.GetProperty("Width").GetInt32();
            targetHeight = doc.GetProperty("Height").GetInt32();
            colorTolerance = doc.GetProperty("Tolerance").GetInt32();
            if (doc.TryGetProperty("Mode", out var m)) isTapestryMode = m.GetBoolean();
            allColors = JsonSerializer.Deserialize<List<PaletteColor>>(doc.GetProperty("Palette").GetRawText())!;
            rows = JsonSerializer.Deserialize<List<StitchRow>>(doc.GetProperty("Rows").GetRawText())!;
            editableGrid = new int[targetWidth, targetHeight];
            foreach (var row in rows)
            {
                int xOffset = 0;
                var segments = row.DirectionLabel.Contains("←") ? row.Segments.AsEnumerable().Reverse() : row.Segments;
                foreach (var seg in segments)
                    for (int i = 0; i < seg.Count; i++)
                        editableGrid[xOffset++, row.RowNumber - 1] = seg.ColorIndex;
            }
            ReconstructPreview();
        }
        catch { }
        isProcessing = false;
    }

    // --- Utils ---
    async Task CancelEditor() { isEditorOpen = false; isDirty = false; await ToggleScroll(true); }
    async Task OpenEditor() { if (rows?.Any() == true) { zoomIndex = 3; isDirty = false; await ToggleScroll(false); isEditorOpen = true; } }
    async Task ToggleScroll(bool enable) => await JS.InvokeVoidAsync("eval", $"document.body.style.overflow = '{(enable ? "auto" : "hidden")}'");
    int FindBestColorMatch(byte r, byte g, byte b)
    {
        double maxDist = colorTolerance * 12.0;
        for (int i = 0; i < allColors.Count; i++)
        {
            double dist = Math.Sqrt(Math.Pow(r - allColors[i].R, 2) + Math.Pow(g - allColors[i].G, 2) + Math.Pow(b - allColors[i].B, 2));
            if (dist <= maxDist) return i;
        }
        return -1;
    }
    PaletteColor GetPixelColor(int x, int y) => allColors[editableGrid[x, y]];
    void ApplyCustomColorToSelection() { try { var color = Rgba32.ParseHex(customColor); allColors.Add(new PaletteColor { R = color.R, G = color.G, B = color.B }); selectedPaletteIdx = allColors.Count - 1; isDirty = true; } catch { } }
    void ToggleSegment(StitchRow row, ColorSegment segment) { segment.IsStitched = !segment.IsStitched; row.IsCompleted = row.Segments.All(s => s.IsStitched); }
    void ToggleRowManual(StitchRow row, ChangeEventArgs args) { bool val = (bool)(args.Value ?? false); row.IsCompleted = val; foreach (var s in row.Segments) s.IsStitched = val; }
    void ClearAll() { rows.Clear(); allColors.Clear(); previewBase64 = ""; originalImageBytes = null; isOriginalSize = false; }
}